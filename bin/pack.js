#!/usr/bin/env node

var Snockets, config, dispatcher, events, fs, merge, path, program;

Snockets = require('snockets');

program = require('commander');

events = require('events');

fs = require('fs');

path = require('path');

dispatcher = new events.EventEmitter;

program.version('0.0.2').option('-w, --watch <directory>', 'Directory to watch file changes within').option('-o, --output <directory>', 'Directory to output changed files').option('-i, --input <file>', 'Input file').option('-m, --minify', 'Minify the JavaScript output').parse(process.argv);

config = {
  minify: !!program.minify,
  watch: program.watch,
  output: program.output
};

merge = {
  single: function(file, callback) {
    var js, outputFile, result, snockets, that;
    snockets = new Snockets();
    that = this;
    js = snockets.getConcatenation(file, {
      minify: config.minify,
      async: false
    });
    result = "// Generated by CoffeeScript" + (program.minify ? ', minified with UglifyJS' : '') + "\n" + js;
    outputFile = path.resolve(config.output, path.basename(file, '.coffee')) + '.js';
    if (config.output) {
      return fs.writeFile(outputFile, result, function(err) {
        var now;
        if (err) {
          console.log(err);
        }
        now = new Date;
        console.log("[" + (that.padZero(now.getHours())) + ":" + (that.padZero(now.getMinutes())) + ":" + (that.padZero(now.getSeconds())) + "] Updated " + outputFile);
        return typeof callback === "function" ? callback() : void 0;
      });
    } else {
      console.log(result);
      return typeof callback === "function" ? callback() : void 0;
    }
  },
  batch: function() {
    var file, _i, _len, _ref, _results;
    _ref = this.topLevelFiles;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      file = _ref[_i];
      _results.push(this.single(file));
    }
    return _results;
  },
  watchDir: function(directory, callback) {
    var that;
    that = this;
    fs.readdir(directory, function(err, files) {
      var file, fullPath, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        fullPath = path.resolve(directory, file);
        _results.push((function(fullPath) {
          return fs.stat(fullPath, function(err, stats) {
            if (stats.isDirectory()) {
              return merge.watchDir(fullPath, callback);
            } else {
              if (path.dirname(fullPath) === path.resolve(config.watch)) {
                return dispatcher.emit('topLevelFile:added', fullPath);
              }
            }
          });
        })(fullPath));
      }
      return _results;
    });
    return fs.watch(directory, function(event, fileName) {
      return typeof callback === "function" ? callback() : void 0;
    });
  },
  padZero: function(number) {
    return (number < 10 ? '0' : '') + number;
  },
  topLevelFiles: []
};

dispatcher.on('mode:compile', function(params) {
  return merge.single(params.file, function() {
    return dispatcher.emit('exit');
  });
});

dispatcher.on('mode:watch', function(params) {
  if (!path.existsSync(config.output)) {
    fs.mkdirSync(config.output);
  }
  return merge.watchDir(params.directory, function() {
    return merge.batch();
  });
});

dispatcher.on('topLevelFile:added', function(path) {
  merge.topLevelFiles.push(path);
  return merge.batch();
});

dispatcher.on('exit', function() {
  return process.exit();
});

if (program.watch) {
  dispatcher.emit('mode:watch', {
    directory: program.watch,
    output: program.output
  });
} else {
  dispatcher.emit('mode:compile', {
    file: program.input
  });
}
